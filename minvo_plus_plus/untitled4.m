% /* ----------------------------------------------------------------------------
%  * Copyright 2020, Jesus Tordesillas Torres, Aerospace Controls Laboratory
%  * Massachusetts Institute of Technology
%  * All Rights Reserved
%  * Authors: Jesus Tordesillas, et al.
%  * See LICENSE file for the license information
%  * -------------------------------------------------------------------------- */

%% RESULT for 3D for a given curve
close all; clear; clc;
addpath(genpath('./../submodules/minvo/src/utils'));
addpath(genpath('./../submodules/minvo/src/solutions'));
interv=[-1,1];
syms t real; T3=[t*t*t t*t t 1]';
% 
% view1=30; view2=30; figure;  set(gcf, 'Position',  [500, 500, 3000, 1000])
% 
% %The given polynomial curve
% % P=[   1    0   0    0.3999;
% %       0.3365    0.8679   -0.2322    0.2508;
% %       0.4907   -0.0914   -0.8137    0.4999];
% %   
% P=[eye(3), zeros(3,1)];
% 
% disp("______________________________");
% %%%% MINVO basis
% subplot(1,3,1);hold on; plotAxesArrows(1.0);
% 
% A=getA_MV(3,interv);
% pol_x=P(1,:)'; pol_y=P(2,:)'; pol_z=P(3,:)';
% 
% volumen_minvo=plot_convex_hull(pol_x,pol_y,pol_z,A,'g',0.017);
% fplot3(pol_x'*T3,pol_y'*T3,pol_z'*T3,interv,'r','LineWidth',3); view(view1, view2); axis equal;
% 
% disp("The vertexes of the simplex generated by the MINVO basis are");
% V=P*inv(A)
% fprintf("Total volume of the simplex=%f\n", volumen_minvo)
% 
% disp("______________________________");


figure;hold on; view1=54; view2=-4.5;
% 
% V=[zeros(3,1) eye(3)];
% vx=V(1,:)';   vy=V(2,:)';  vz=V(3,:)';
A=getA_MV(3,interv);  


P=[rot90(eye(3)), zeros(3,1)];

V=P*inv(A);

pol_x=P(1,:)';  pol_y=P(2,:)';  pol_z=P(3,:)';

sizes_spheres=0.015;

volumen_mio=plot_convex_hull(pol_x,pol_y,pol_z,A,'g',sizes_spheres);
view(view1, view2);  axis equal; ylim([-1.5,1.5]);

%This epsilons are simply to avoid artificial effects with MATLAB plotting
%(which happen when two surfaces are very close to each other)
tol_for_visual=0.003
tol_for_visual2=0.013;
pol_x_tmp=(pol_x+[0 0 0 tol_for_visual]')/(1+tol_for_visual2)
pol_y_tmp=(pol_y+[0 0 0 tol_for_visual]')/(1+tol_for_visual2)
pol_z_tmp=(pol_z+[0 0 0 tol_for_visual]')/(1+tol_for_visual2)

poly=[pol_x_tmp'*T3,pol_y_tmp'*T3,pol_z_tmp'*T3]';
samples_t=min(interv):0.01:max(interv);
samples_poly=double(subs(poly,t,samples_t));
[k1,av1] = convhull(samples_poly(1,:)',samples_poly(2,:)',samples_poly(3,:)');
trisurf(k1,samples_poly(1,:)',samples_poly(2,:)',samples_poly(3,:)','EdgeColor','none','FaceAlpha' ,0.3)%,'FaceColor','cyan'
fplot3(pol_x_tmp'*T3,pol_y_tmp'*T3,pol_z_tmp'*T3,interv,'r','LineWidth',3);
camlight; lightangle(gca,45,0)
colormap(winter); axis equal; axis off; 
caxis([0.2 0.7])

mean1=mean(V(:,1:3),2);
mean2=mean(V(:,2:4),2);
mean3=mean(V(:,[1,2,4]),2);
mean4=mean(V(:,[1,3,4]),2);

plotSphere(mean1,sizes_spheres,'g')
plotSphere(mean2,sizes_spheres,'g')
plotSphere(mean3,sizes_spheres,'g')
plotSphere(mean4,sizes_spheres,'g')

v0=V(:,1); v1=V(:,2); v2=V(:,3); v3=V(:,4);

all_roots=getAllRoots_MV(3,interv);
for roots_i=all_roots
    pt=double(P*subs(T3,t,roots_i));
    plotSphere(pt,sizes_spheres,'r')
end

ta=all_roots(end-1);
tb=all_roots(end-2);

Pm1=double(P*subs(T3,t,-1));
Pmtb=double(P*subs(T3,t,-tb));
Pmta=double(P*subs(T3,t,-ta));
Ptb=double(P*subs(T3,t,tb));
Pta=double(P*subs(T3,t,ta));
P1=double(P*subs(T3,t,1));

plotsegment(P1,Pmta,'c',1)
plotsegment(P1,Ptb,'c',1)
plotsegment(Pm1,Pta,'c',1)
plotsegment(Pm1,Pmtb,'c',1)

%Plot the legend (by hand)
s1=[0 0.5 2];
s2=[0 0.5 1.9];
s3=[0 0.5 1.8];
plotSphere(s1,0.02,'r')
plotSphere(s2,0.02,'g')
plotSphere(s3,0.02,[.98 .45 .02])
text(s1(1),s1(2)+0.05,s1(3), "Contact points");
text(s2(1),s2(2)+0.05,s2(3), "Centroid of each face");
text(s3(1),s3(2)+0.05,s3(3), "Control points");

Vsmall=[mean1 mean2 mean3 mean4];
[k1,av1] = convhull(Vsmall(1,:)',Vsmall(2,:)',Vsmall(3,:)');
trisurf(k1,Vsmall(1,:)',Vsmall(2,:)',Vsmall(3,:)','FaceColor','yellow','EdgeColor','k','FaceAlpha' ,1.0)

grid on
axis on
xlabel('x')
ylabel('y')
zlabel('z')

%%
fplot3(pol_x_tmp'*T3,pol_y_tmp'*T3,pol_z_tmp'*T3,interv,'r','LineWidth',3);


%%

v0=sym('v0',[3,1], 'real')
v1=sym('v1',[3,1], 'real')
v2=sym('v2',[3,1], 'real')
v3=sym('v3',[3,1], 'real')


c1 = (v0+v1+v2)/3.0;
c2 = (v1+v2+v3)/3.0;
c3 = (v0+v1+v3)/3.0;
c4 = (v0+v2+v3)/3.0;

det(generateMatrix1(c1))

C1=generateMatrix1(c1);
C2=generateMatrix1(c2);
C3=generateMatrix2(c3);
C4=generateMatrix2(c4);

disp("Going to solve")
s=solve([simplify(det(C1))==0, simplify(det(C2))==0, simplify(det(C3))==0, simplify(det(C4))==0], symvar([c1;c2;c3;c4]), 'Real', true  )

subs(c1,s)'
subs(c2,s)'
subs(c3,s)'
subs(c4,s)'


function result=generateMatrix1(centroid)
mu0=1;
mu1=centroid(1);
mu2=centroid(2);
mu3=centroid(3);

result=[mu0+mu1 mu1+mu2;
   mu1+mu2 mu2+mu3];

end

function result=generateMatrix2(centroid)
mu0=1;
mu1=centroid(1);
mu2=centroid(2);
mu3=centroid(3);

result=[mu0-mu1 mu1-mu2;
   mu1-mu2 mu2-mu3];

end



