#Params for CVX planner

use_ff: true # use feedforward
visual: true #publish visualization stuff
dc: 0.01            #(seconds) Duration for the interpolation=Value of the timer pubGoal
goal_radius: 0.3    #(m) Drone has arrived to the goal when distance_to_goal<GOAL_RADIUS
drone_radius: 0.3  #(m) Used for collision checking

N_whole: 6 #[-] Number of discretization points in the whole trajectory
N_safe: 6 #[-] Number of discretization points in the safe path

factor_deltaT: 3
factor_min_deltaT: 1

min_states_deltaT: 0  #15

Ra: 0.5            # [m] Minimum radius of the first sphere
Ra_max: 4            # [m] Maximum radius of the first sphere
Rb: 9.0             # [m] Radius of the second sphere
w_max: 1          # [rd/s] Maximum angular velocity. 0.4 for Hardware
alpha_filter_dyaw: 0 #was 0.92  #[] Filter parameter for dyaw, \in [0,1]. Higher--> More aggressive filtering

alpha_0_deg: 1500         #[deg] threshold to ignore current JPS solution, and consider the old one. 0--> always decide
z_ground: -0.2         #[m] points below this are considered ground
z_max: 2         #[m] JPS is not allowed to give a solution that goes higher than this height
inflation_jps: 0.6  #[m] The obstacles are inflated (to run JPS) by this amount
factor_jps: 1  #[m] JPS is run with resolution=factor_jps*(resolution of the map)


v_max: 5.0   #[m/s]  1.4
a_max: 5.0   #[m/s2] 1.4
j_max: 8.0  #[m/s3] 35

z_land: 0.02 #[m] z goal for landing

#Factors for time allocation
gamma_whole: 20       #[-]
gammap_whole: 20  #[-]
increment_whole: 0.1 #[-]

gamma_safe: 20         #[-]
gammap_safe: 20    #[-]
increment_safe: 0.1   #[-]

max_poly_whole: 3 #Should be less than N_whole 
max_poly_safe: 3 #Should be less than N_safe
dist_max_vertexes: 1.5 #[m] Maximum distance between two vertexes in the JPS before doing the cvx decomp (more vertexes are added to force this)
gurobi_threads: 1 #[threads] Number of threads that Gurobi will use. If computer is maxed out, threads=1 works faster!
gurobi_verbose: 0 #Verbosity of Gurobi. 0 or 1

#Parameters for the ground robot:
kw: 1
kyaw: 1.5
kdalpha: 0.0
kalpha: 3

kv: 2
kdist: 2

delta_a: 1.0
delta_H: 1.0

hack: 0.75

use_faster: true  #if false, it will plan only in free space
keep_optimizing_after_found: false #if true, the planner will keep optimizing after having found a trajectory (until the drone arrives at point A)
use_smart_deltaT: false #if true, A will be tried be be chosen in R{k-1} (unless there is too little time remaining, given by factor_min_deltaT)



