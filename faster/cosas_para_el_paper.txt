--> Stop condition is not a safe condition in dynamic world

--> Distintos origenes de tiempo (debo tener en cuenta delta_T)

--> Tener en cuenta delta_T y ajustar el runtime de la optimization according to that

--> Get last feasible solution if it fails

--> Explicar la formula para minimizar el jerk (no la he visto usar en otros papers)

--> Explicar c'omo pasar de control points de la curva de un B-Spline a control points de la curva Vopt. 

--> El paso de B-Spline a Bezier ya lo hizo el paper "Real-time Trajectory Generation for quads using B-spline based Non-uniform Kinodynamic Search". Pero el paso de Bezier al de menor volumen no lo ha hecho nadie de planning (aunque fue demostrado en el paper "Polynomial bases for quadratic and cubic polynomials which yield control points with small convex hulls")

--> Options para la initial guess:
------> Run JPS con dynamic obstacle = static obstacle
------> Run 
------> My algorithm

--> Que la primera figura del paper sea una simulacion donde haya obstaculos est'aticos, dinamicos y agents

Should I optimize further the initial guess, or should I go with the last feasible solution?

--> Para avoid infinite loops en los checks, al final va un check en el que asumes que tarda 0 segundos

La forma correcta de hacerlo es ir creando libraries en el CMakeLists.txt

--> Sacar el envelove de los MinVo polynomials: https://mathworld.wolfram.com/BernsteinPolynomial.html
(ver lo de abajo)

--> extenderlo a surfaces la MINVO basis?

--> Explicar la relaci'on entre MINVO basis y probabilidad

--> Cuidado porque si las multi agent simulations las hago muy cerca del suelo, puedo estar impidiendo a los agentes a planificar cerca del suelo

--> Explicar que como allocate el total time en, parte A*, parte NLoptimization




Posibles results:
--> Usar mi algoritmo, pero cogiendo todo el espacio como ocupado (i.e. no hacer intervalos) 
--> Sequential? 
--> 3D RVO (showing tracking error)
[Matlab]--> MINVO vs Bezier vs Bspline Basis (en un example de una trajectory cualquiera)
--> Graph showing the decrease in the cost done by the optimization wrt the cost of the initial guess

Medir:
--> Distancia total (can be obtained from rosbag, but maybe better to log)
--> Tiempo (can be obtained from rosbag, but maybe easier to log it (from goal_received to goal_reached))
--> Success rate??

Computation times
--> A*, NLOpt,


Posibles escenarios de simulaciÃ³n:

--> random forest con moving/stopped trees ("moving forest")
--> same, but with several agents (starting from a sphere?)
--> wild corridor
--> moving gates 
--> bounding balls (bolas que caen desde el cielo siguiendo una par'abola )
--> sphere

TODOs:
0.6?? aqu'i:  double t_max = t_min + (goal - q0).norm() / (0.6 * v_max(0));
Mejorar cost-to-go en la A* guess
Usar MINVO basis tambien en velocity/acceleration space?

BUG TODO: cuando uso MINVO, estoy permitiendo que los B-Spline Control points est'en dentro del obstaculo (lo cual est'a bien, los control points de MINVO pueden estar perfectamente fuera)
	      Sin embargo, cuando en A* me quedo con la soluci'on m'as cerca del goal, si esa soluci'on no tiene longitud m'axima, esto significa que puedo estar cogiendo un control point que est'a dentro del obstaculo. 


Ahora mismo, cuando genero straight line guess, n y d los calculo con la library "separator". Lo dejo as'i?, o pongo la opci'on de random?

creo que el A* ahora mismo tiene un bias (mirar el plot que sale, siempre tiende hacia el mismo lado). Creo que es porque, una vez 
te mueves para y<0 (por ejempo), la constraint en velocidad [yL yU] tambi'en se mueve en esa direccti'on, y se va a samplear en esa direcci'on m'as. 

--> Si, en el escenario tipo sphere, los de arriba tienen un planning horizon corto, es porque la box del mapa (wdx,wdy,wdz) no es un cubo de lados iguales

