--> Stop condition is not a safe condition in dynamic world

--> Distintos origenes de tiempo (debo tener en cuenta delta_T)

--> Tener en cuenta delta_T y ajustar el runtime de la optimization according to that

--> Get last feasible solution if it fails

--> Explicar la formula para minimizar el jerk (no la he visto usar en otros papers)

--> Explicar c'omo pasar de control points de la curva de un B-Spline a control points de la curva Vopt. 

--> El paso de B-Spline a Bezier ya lo hizo el paper "Real-time Trajectory Generation for quads using B-spline based Non-uniform Kinodynamic Search". Pero el paso de Bezier al de menor volumen no lo ha hecho nadie de planning (aunque fue demostrado en el paper "Polynomial bases for quadratic and cubic polynomials which yield control points with small convex hulls")

--> Options para la initial guess:
------> Run JPS con dynamic obstacle = static obstacle
------> Run 
------> My algorithm

--> Que la primera figura del paper sea una simulacion donde haya obstaculos est'aticos, dinamicos y agents

Should I optimize further the initial guess, or should I go with the last feasible solution?

--> Para avoid infinite loops en los checks, al final va un check en el que asumes que tarda 0 segundos

La forma correcta de hacerlo es ir creando libraries en el CMakeLists.txt

--> Sacar el envelove de los MinVo polynomials: https://mathworld.wolfram.com/BernsteinPolynomial.html
(ver lo de abajo)

--> extenderlo a surfaces la MINVO basis?

--> Explicar la relaci'on entre MINVO basis y probabilidad

--> Cuidado porque si las multi agent simulations las hago muy cerca del suelo, puedo estar impidiendo a los agentes a planificar cerca del suelo

--> Explicar que como allocate el total time en, parte A*, parte NLoptimization

--> Explicar c'omo funciona el local map y las FOV constraints.

--> El video/paper deberia empezar diciendo "FOV constraints + static obs + dyn obtacles + other agents".

========================
Tips:
--> El A* no esta garantizado que d'e feasible solution (wrt acceleration) en los ultimos control points (pues qN y qN-1 los append directly, sin verify if they satisfy the accel constraints wrt qN-2)

--> 
========================

=======================
Params que afectan si se para todo el rato:
--> radius of the local map (the bigger, the more computationally expensive it is)

=======================


Posibles results:
--> Usar mi algoritmo, pero cogiendo todo el espacio como ocupado (i.e. no hacer intervalos) 
--> Sequential? 
--> 3D RVO (showing tracking error)
[Matlab]--> MINVO vs Bezier vs Bspline Basis (en un example de una trajectory cualquiera)
--> Graph showing the decrease in the cost done by the optimization wrt the cost of the initial guess

Medir:
--> Distancia total (can be obtained from rosbag, but maybe better to log)
--> Tiempo (can be obtained from rosbag, but maybe easier to log it (from goal_received to goal_reached))
--> Success rate??

Computation times
--> A*, NLOpt,


Posibles escenarios de simulaciÃ³n:

--> random forest con moving/stopped trees ("moving forest")
--> same, but with several agents (starting from a sphere?)
--> wild corridor
--> moving gates 
--> bounding balls (bolas que caen desde el cielo siguiendo una par'abola )
--> sphere

TODOs:
--> Anadir que el size de los obstaculos aumente a medida de que esten mas lejos (para simular incertidumbre)
--> In checkFeasAndFillND, I should check also the acceleration constraints (which may not be satisfied when I've filled)
0.6?? aqu'i:  double t_max = t_min + (goal - q0).norm() / (0.6 * v_max(0));
Mejorar cost-to-go en la A* guess
Usar MINVO basis tambien en velocity/acceleration space?

BUG TODO: cuando uso MINVO, estoy permitiendo que los B-Spline Control points est'en dentro del obstaculo (lo cual est'a bien, los control points de MINVO pueden estar perfectamente fuera)
	      Sin embargo, cuando en A* me quedo con la soluci'on m'as cerca del goal, si esa soluci'on no tiene longitud m'axima, esto significa que puedo estar cogiendo un control point que est'a dentro del obstaculo. 

--> removeTrajsThatWillNotAffectMe doesn't seem to be working (it leads to collisions at the end of the trajectory in the scenario where multiple agents are on a sphere)

--> Por qu'e se para justo al final de la trajectoria en un obstaculo estatico. Creo que tiene que ver con el size del static obstacle (COM is not inside sphere, pero static obstacle is)
o con la esfera centrada en A en lugar de en el dron (quiza Rlocal mas has to be 2*Ra)

--> Crear el separator problem al principio, no todo el rato (en separator.cpp)

--> Por qu'e alguna vez se para justo en un obstaculo. Tolerance is very big??

--> Eliminar todas las dependencias de jps (creo que ya no estoy usando ninguna)

Ahora mismo, cuando genero straight line guess, n y d los calculo con la library "separator". Lo dejo as'i?, o pongo la opci'on de random?

creo que el A* ahora mismo tiene un bias (mirar el plot que sale, siempre tiende hacia el mismo lado). Creo que es porque, una vez 
te mueves para y<0 (por ejempo), la constraint en velocidad [yL yU] tambi'en se mueve en esa direccti'on, y se va a samplear en esa direcci'on m'as. 

--> Si, en el escenario tipo sphere, los de arriba tienen un planning horizon corto, es porque la box del mapa (wdx,wdy,wdz) no es un cubo de lados iguales
--> Si en el dynamic forest no funciona bien, puede ser porque el radio del dron sea muy grande
--> El bias en A* search era provocado por la constraint n1+n2+n3 <=3 que ten'ia en separator.cpp
--> Si hay muchas ocasiones en que checkFeasAndFillND fails, quiza es porqe a_star_samp_x, a_star_samp_y,a_star_samp_z... sean muy bajas
--> Si el expandAndAddToQueue del A* guess tarda mucho (> 50ms), es porque no estoy haciendo lo de la voxelMap para prune more nodes
--> the solver LD_MMA was not decreasing the cost (i.e the solution was the same as the initial guess, TODO: debug why) 


--> Si a veces el dron hace "espirales", es por la condici'on (qi - q0_).norm() >=Ra_ (tanto en el solver como en la initial guess)
--> Si hay 0 improvement todo el rato (y estoy usando LD_MMA), es porque Ra es super big --> one iteration in the opt alg. takes a lot of time


=========================
